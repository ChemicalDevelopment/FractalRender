/* engine_opencl/engine_opencl.h -- header file for OpenCL engine

  Copyright 2016-2017 ChemicalDevelopment

  This file is part of the FractalRender project.

  FractalRender source code, as well as any other resources in this project are
free software; you are free to redistribute it and/or modify them under
the terms of the GNU General Public License; either version 3 of the
license, or any later version.

  These programs are hopefully useful and reliable, but it is understood
that these are provided WITHOUT ANY WARRANTY, or MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GPLv3 or email at
<info@chemicaldevelopment.us> for more info on this.

  Here is a copy of the GPL v3, which this software is licensed under. You
can also find a copy at http://www.gnu.org/licenses/.

*/


#ifndef __ENGINE_OPENCL_H__
#define __ENGINE_OPENCL_H__

bool engine_opencl_isvalid;


void engine_opencl_init(int __depth, int d0, int d1, int numincol, unsigned char * incol);

void engine_opencl_fulltest(fractal_img_t * ret);

void engine_opencl_end();




// THIS IS AN AUTOGENERATED MACRO:
// use `./utils/convert_kernel.py ./kernel.cl` to regenerate

#define ENGINE_OPENCL_KERNEL_SOURCE_DEFAULT "\n\n#ifdef cl_khr_fp64\n\n__kernel void mand(__global uchar * color_pattern, int color_pattern_length, double color_pattern_scale, double color_pattern_disp, int do_simple_color, __global uchar * color_output, int width, int height, int max_iter, double center_x, double center_y, double zoom, double time)\n{\n    int px = get_global_id(0), py = get_global_id(1);\n\n    double x = center_x + (2 * px - width) / (zoom * width), y = center_y + (height - 2 * py) / (zoom * width);\n\n    double sx = x, sy = y, xs = x * x, ys = y * y, tmp;\n    \n    double er = 16.0;\n    double er2 = er * er;\n\n    int col_dest = 3 * (py * width + px);\n\n\n    int ci;\n    for (ci = 1; ci <= max_iter && xs + ys <= er2; ++ci) {\n        tmp = 2 * x * y;\n        x = xs - ys + sx;\n        y = tmp + sy;\n        xs = x * x;\n        ys = y * y;\n    }\n    if (do_simple_color) {\n        int color_off;\n        \n        if (ci > max_iter) {\n            color_off = 0;\n        } else {\n            color_off = 3*((int)floor(ci * color_pattern_scale + color_pattern_disp) % color_pattern_length);\n        }\n\n\n\n        color_output[col_dest + 0] = color_pattern[color_off + 0];\n        color_output[col_dest + 1] = color_pattern[color_off + 1];\n        color_output[col_dest + 2] = color_pattern[color_off + 2];\n    } else {\n        double zn = xs + ys;\n        double hue;\n        if (zn <= er2) {\n            hue = 0;\n        } else {\n            hue = ci + 1.0 - log(fabs(zn)) / log(er2);\n        }\n\n        hue = hue * color_pattern_scale + color_pattern_disp;\n        \n        hue = fmod(fmod(hue, color_pattern_length) + color_pattern_length, color_pattern_length);\n\n        tmp = hue - floor(hue);\n        int color_off0 = 3 * ((int)floor(hue) % color_pattern_length);\n        int color_off1;\n        if (color_off0 >= 3 *(color_pattern_length - 1)) {\n            color_off1 = 0;\n        } else {\n            color_off1 = color_off0 + 3;\n        }\n\n        color_output[col_dest + 0] = ((uchar)floor(tmp*color_pattern[color_off1 + 0]+(1-tmp)*color_pattern[color_off0 + 0]));\n        color_output[col_dest + 1] = ((uchar)floor(tmp*color_pattern[color_off1 + 1]+(1-tmp)*color_pattern[color_off0 + 1]));\n        color_output[col_dest + 2] = ((uchar)floor(tmp*color_pattern[color_off1 + 2]+(1-tmp)*color_pattern[color_off0 + 2]));\n    }\n}\n\n#endif\n      \n__kernel void mand_32(__global uchar * color_pattern, int color_pattern_length, float color_pattern_scale, float color_pattern_disp, int do_simple_color, __global uchar * color_output, int width, int height, int max_iter, float center_x, float center_y, float zoom, float time)\n{\n    int px = get_global_id(0), py = get_global_id(1);\n\n    float x = center_x + (2 * px - width) / (zoom * width), y = center_y + (height - 2 * py) / (zoom * width);\n\n    float sx = x, sy = y, xs = x * x, ys = y * y, tmp;\n    \n    float er = 16.0f;\n    float er2 = er * er;\n\n    int col_dest = 3 * (py * width + px);\n\n    int ci;\n    for (ci = 1; ci <= max_iter && xs + ys <= er2; ++ci) {\n        tmp = 2 * x * y;\n        x = xs - ys + sx;\n        y = tmp + sy;\n        xs = x * x;\n        ys = y * y;\n    }\n    if (do_simple_color) {\n        int color_off;\n        \n        if (ci > max_iter) {\n            color_off = 0;\n        } else {\n            color_off = 3*((int)floor(ci * color_pattern_scale + color_pattern_disp) % color_pattern_length);\n        }\n\n        color_output[col_dest + 0] = color_pattern[color_off + 0];\n        color_output[col_dest + 1] = color_pattern[color_off + 1];\n        color_output[col_dest + 2] = color_pattern[color_off + 2];\n    } else {\n        float zn = xs + ys;\n        float hue;\n        if (zn <= er2) {\n            hue = 0;\n        } else {\n            hue = ci + 1.0f - log(fabs(zn)) / log(er2);\n        }\n\n        hue = hue * color_pattern_scale + color_pattern_disp;\n        \n        hue = fmod(fmod(hue, color_pattern_length) + color_pattern_length, color_pattern_length);\n\n        tmp = hue - floor(hue);\n        int color_off0 = 3 * ((int)floor(hue) % color_pattern_length);\n        int color_off1;\n        if (color_off0 >= 3 *(color_pattern_length - 1)) {\n            color_off1 = 0;\n        } else {\n            color_off1 = color_off0 + 3;\n        }\n\n        color_output[col_dest + 0] = ((uchar)floor(tmp*color_pattern[color_off1 + 0]+(1-tmp)*color_pattern[color_off0 + 0]));\n        color_output[col_dest + 1] = ((uchar)floor(tmp*color_pattern[color_off1 + 1]+(1-tmp)*color_pattern[color_off0 + 1]));\n        color_output[col_dest + 2] = ((uchar)floor(tmp*color_pattern[color_off1 + 2]+(1-tmp)*color_pattern[color_off0 + 2]));\n    }\n}\n\n\n"



#endif

