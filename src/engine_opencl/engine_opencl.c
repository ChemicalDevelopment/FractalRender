/* engine_opencl/engine_opencl.c -- Engine that uses OpenCL kernel

  Copyright 2016-2017 ChemicalDevelopment

  This file is part of the FractalRender project.

  FractalRender source code, as well as any other resources in this project are
free software; you are free to redistribute it and/or modify them under
the terms of the GNU General Public License; either version 3 of the
license, or any later version.

  These programs are hopefully useful and reliable, but it is understood
that these are provided WITHOUT ANY WARRANTY, or MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GPLv3 or email at
<info@chemicaldevelopment.us> for more info on this.

  Here is a copy of the GPL v3, which this software is licensed under. You
can also find a copy at http://www.gnu.org/licenses/.

*/


#include "fractalrender.h"


bool engine_opencl_isvalid = false;


#define MAX_SOURCE_SIZE (0x100000)




// THIS IS AN AUTOGENERATED MACRO:
// use `./utils/convert_kernel.py ./kernel.cl` to regenerate

#define ENGINE_OPENCL_KERNEL_SOURCE_DEFAULT "\n\n#ifdef cl_khr_fp64\n\n__kernel void mand(__global uchar * color_pattern, int color_pattern_length, double color_pattern_scale, double color_pattern_disp, int do_simple_color, __global uchar * color_output, int width, int height, int max_iter, double center_x, double center_y, double zoom, double time)\n{\n    int px = get_global_id(0), py = get_global_id(1);\n\n    double x = center_x + (2 * px - width) / (zoom * width), y = center_y + (height - 2 * py) / (zoom * width);\n\n    double sx = x, sy = y, xs = x * x, ys = y * y, tmp;\n    \n    double er = 16.0;\n    double er2 = er * er;\n\n    int col_dest = 3 * (py * width + px);\n\n\n    int ci;\n    for (ci = 1; ci <= max_iter && xs + ys <= er2; ++ci) {\n        tmp = 2 * x * y;\n        x = xs - ys + sx;\n        y = tmp + sy;\n        xs = x * x;\n        ys = y * y;\n    }\n    if (do_simple_color) {\n        int color_off;\n        \n        if (ci > max_iter) {\n            color_off = 0;\n        } else {\n            color_off = 3*((int)floor(ci * color_pattern_scale + color_pattern_disp) % color_pattern_length);\n        }\n\n\n\n        color_output[col_dest + 0] = color_pattern[color_off + 0];\n        color_output[col_dest + 1] = color_pattern[color_off + 1];\n        color_output[col_dest + 2] = color_pattern[color_off + 2];\n    } else {\n        double zn = xs + ys;\n        double hue;\n        if (zn <= er2) {\n            hue = 0;\n        } else {\n            hue = ci + 1.0 - log(fabs(zn)) / log(er2);\n        }\n\n        hue = hue * color_pattern_scale + color_pattern_disp;\n        \n        hue = fmod(fmod(hue, color_pattern_length) + color_pattern_length, color_pattern_length);\n\n        tmp = hue - floor(hue);\n        int color_off0 = 3 * ((int)floor(hue) % color_pattern_length);\n        int color_off1;\n        if (color_off0 >= 3 *(color_pattern_length - 1)) {\n            color_off1 = 0;\n        } else {\n            color_off1 = color_off0 + 3;\n        }\n\n        color_output[col_dest + 0] = ((uchar)floor(tmp*color_pattern[color_off1 + 0]+(1-tmp)*color_pattern[color_off0 + 0]));\n        color_output[col_dest + 1] = ((uchar)floor(tmp*color_pattern[color_off1 + 1]+(1-tmp)*color_pattern[color_off0 + 1]));\n        color_output[col_dest + 2] = ((uchar)floor(tmp*color_pattern[color_off1 + 2]+(1-tmp)*color_pattern[color_off0 + 2]));\n    }\n}\n\n#endif\n      \n__kernel void mand_32(__global uchar * color_pattern, int color_pattern_length, float color_pattern_scale, float color_pattern_disp, int do_simple_color, __global uchar * color_output, int width, int height, int max_iter, float center_x, float center_y, float zoom, float time)\n{\n    int px = get_global_id(0), py = get_global_id(1);\n\n    float x = center_x + (2 * px - width) / (zoom * width), y = center_y + (height - 2 * py) / (zoom * width);\n\n    float sx = x, sy = y, xs = x * x, ys = y * y, tmp;\n    \n    float er = 16.0f;\n    float er2 = er * er;\n\n    int col_dest = 3 * (py * width + px);\n\n    int ci;\n    for (ci = 1; ci <= max_iter && xs + ys <= er2; ++ci) {\n        tmp = 2 * x * y;\n        x = xs - ys + sx;\n        y = tmp + sy;\n        xs = x * x;\n        ys = y * y;\n    }\n    if (do_simple_color) {\n        int color_off;\n        \n        if (ci > max_iter) {\n            color_off = 0;\n        } else {\n            color_off = 3*((int)floor(ci * color_pattern_scale + color_pattern_disp) % color_pattern_length);\n        }\n\n        color_output[col_dest + 0] = color_pattern[color_off + 0];\n        color_output[col_dest + 1] = color_pattern[color_off + 1];\n        color_output[col_dest + 2] = color_pattern[color_off + 2];\n    } else {\n        float zn = xs + ys;\n        float hue;\n        if (zn <= er2) {\n            hue = 0;\n        } else {\n            hue = ci + 1.0f - log(fabs(zn)) / log(er2);\n        }\n\n        hue = hue * color_pattern_scale + color_pattern_disp;\n        \n        hue = fmod(fmod(hue, color_pattern_length) + color_pattern_length, color_pattern_length);\n\n        tmp = hue - floor(hue);\n        int color_off0 = 3 * ((int)floor(hue) % color_pattern_length);\n        int color_off1;\n        if (color_off0 >= 3 *(color_pattern_length - 1)) {\n            color_off1 = 0;\n        } else {\n            color_off1 = color_off0 + 3;\n        }\n\n        color_output[col_dest + 0] = ((uchar)floor(tmp*color_pattern[color_off1 + 0]+(1-tmp)*color_pattern[color_off0 + 0]));\n        color_output[col_dest + 1] = ((uchar)floor(tmp*color_pattern[color_off1 + 1]+(1-tmp)*color_pattern[color_off0 + 1]));\n        color_output[col_dest + 2] = ((uchar)floor(tmp*color_pattern[color_off1 + 2]+(1-tmp)*color_pattern[color_off0 + 2]));\n    }\n}\n\n\n"




#define CL_MAXPLATFORMS 10
#define CL_MAXDEVICES 10


cl_context context = NULL;
cl_command_queue command_queue = NULL;
cl_program program = NULL;
cl_kernel kernel = NULL;

cl_device_id device_id[CL_MAXDEVICES];
cl_uint res_num_devices;

cl_platform_id platform_id[CL_MAXPLATFORMS];
cl_uint res_num_platforms;

cl_int res;

cl_mem color_pattern_m, color_output_m;

bool cl_32, cl_64;
bool using_cl_32;

char *kernelname;

char *source_str;
size_t source_size;

size_t *global_item_size;
size_t *local_item_size;

void engine_opencl_error_handle(char *file, int line, char *src, int code) {
    printf("OpenCL error code: %d\n", code);
    printf("%s:%d\n", file, line);
    printf("%s\n", src);
    exit(3);
}


#define CLGLBL_HNDL_S(ST, IS, ES) ST; if (res) { IS; } else { ES; }

#define CLGLBL_HNDL(ST) CLGLBL_HNDL_S(ST, engine_opencl_error_handle(__FILE__, __LINE__, #ST, res), )



bool engine_opencl_set_kernel__dev(int platid, int devid, bool doexit) {
    printf("Trying platform[%d], device[%d]\n", platid, devid);

    CLGLBL_HNDL(command_queue = clCreateCommandQueue(context, device_id[devid], 0, &res));

    CLGLBL_HNDL(program = clCreateProgramWithSource(context, 1, (const char **)&source_str, (const size_t *)&source_size, &res));

    CLGLBL_HNDL(res = clBuildProgram(program, res_num_devices, device_id, NULL, NULL, NULL));

    printf("looking for kernel `%s`...", kernelname);

    CLGLBL_HNDL_S(kernel = clCreateKernel(program, kernelname, &res),

        if (cl_32 && !cl_64) {
            printf("ERROR: Couldn't find kernel `mand_32`, try omitting all `-CLXX` arguments\n");
            if (doexit) {
                FR_FAIL
            }
            return false;
        } else if (cl_64 && !cl_32) {
            printf("ERROR: You requested 64 bit (using `-CL64`), but could not find a 64 bit kernel\n");
            if (doexit) {
                FR_FAIL
            }
            return false;
        } else {
            kernelname = "mand_32";
            using_cl_32 = true;

            printf("no\nlooking for kernel `%s`...", kernelname);
            CLGLBL_HNDL_S(kernel = clCreateKernel(program, kernelname, &res),

                printf("no\n");
                printf("ERROR: Couldn't find kernel `mand_32`, try omitting all `-CLXX` arguments\n");
                if (doexit) {
                    FR_FAIL
                }
                return false;
                ,
                printf("yes\n");
                return true;
            )
        }
        ,
        printf("yes\n");
        return true;
    );
}

bool engine_opencl_set_kernel__plat(int platid, bool doexit, int clgdif) {
    printf("Trying platform[%d]\n", platid);
    CLGLBL_HNDL_S(res = clGetDeviceIDs(platform_id[platid], clgdif, CL_MAXDEVICES, device_id, &res_num_devices),
        if (res == -1) {
            printf("Device not found for platform[%d]\n", platid);
            if (doexit) {
                FR_FAIL
            }
            return false;
        } else {
            CLGLBL_HNDL()
        }
    ,
        //
    );
    printf("OpenCL: found %d devices on platform[%d]\n", res_num_devices, platid);
    int devid;
    CLGLBL_HNDL(context = clCreateContext(0, res_num_devices, device_id, NULL, NULL, &res));
    if (cargs_get_flag("-CLdevice")) {
        devid = cargs_get_int("-CLdevice");
        if (!engine_opencl_set_kernel__dev(platid, devid, true)) {
            if (doexit) {
                FR_FAIL
            }
            return false;
        } else {
            return true;
        }
    } else {
        for (devid = 0; devid < res_num_devices; ++devid) {
            if (engine_opencl_set_kernel__dev(platid, devid, false)) {
                return true;
            }
        }
        if (doexit) {
            FR_FAIL
        }
        return false;
    }
}

void engine_opencl_set_kernel() {
    cl_32 = cargs_get_flag("-CL32");
    cl_64 = cargs_get_flag("-CL64");

    int platid;

    if (cl_32 && !cl_64) {
        kernelname = "mand_32";
        using_cl_32 = true;
    } else {
        kernelname = "mand";
        using_cl_32 = false;
    }

    char * cl_dev_type = cargs_get("-CLtype");
    long clgdif = CL_DEVICE_TYPE_DEFAULT;


    if (cargs_get_flag("-CLkernel")) {
        FILE *fp = fopen(cargs_get("-CLkernel"), "r");
        source_str = (char*)malloc(MAX_SOURCE_SIZE);
        source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);
        fclose(fp);
    } else {
        source_str = ENGINE_OPENCL_KERNEL_SOURCE_DEFAULT;
        source_size = strlen(source_str);
    }

    if (strcmp(cl_dev_type, "CPU") == 0) {
        clgdif = CL_DEVICE_TYPE_CPU;
    } else if (strcmp(cl_dev_type, "GPU") == 0) {
        clgdif = CL_DEVICE_TYPE_GPU;
    } else if (strcmp(cl_dev_type, "ALL") == 0) {
        clgdif = CL_DEVICE_TYPE_ALL;
    } else if (strcmp(cl_dev_type, "ACCELERATOR") == 0) {
        clgdif = CL_DEVICE_TYPE_ACCELERATOR;
    } else if (strcmp(cl_dev_type, "DEFAULT") == 0) {
        clgdif = CL_DEVICE_TYPE_DEFAULT;
    } else {
        printf("Unknown OpenCL device type: '%s' (try CPU, GPU, ALL, ACCELERATOR, DEFAULT)\n", cl_dev_type);
        FR_FAIL
    }

    printf("Looking for %s devices\n", cl_dev_type);

    CLGLBL_HNDL(res = clGetPlatformIDs(CL_MAXPLATFORMS, platform_id, &res_num_platforms));

    printf("OpenCL: found %d platforms\n", res_num_platforms);


    if (cargs_get_flag("-CLplatform")) {
        platid = cargs_get_int("-CLplatform");
        if (engine_opencl_set_kernel__plat(platid, true, clgdif)) {
            return;
        } else {
            FR_FAIL
        }
    } else {
        for (platid = 0; platid < res_num_platforms; ++platid) {
            if (engine_opencl_set_kernel__plat(platid, false, clgdif)) {
                return;
            }
        }
        FR_FAIL
    }
    FR_FAIL
    return;
}


void engine_opencl_init(int __depth, int d0, int d1, int numincol, unsigned char *incol) {

    if (engine_opencl_isvalid) {
        return;
    }
    engine_opencl_isvalid = true;

    engine_opencl_set_kernel();
    printf("Succsessfully found kernel `%s`\n", kernelname);


    global_item_size = (size_t *)malloc(sizeof(size_t) * 2);
    local_item_size = (size_t *)malloc(sizeof(size_t) * 2);
    global_item_size[0] = d0;
    global_item_size[1] = d1;
    local_item_size[0] = cargs_get_int_idx("-CLsize", 0);
    local_item_size[1] = cargs_get_int_idx("-CLsize", 1);

    CLGLBL_HNDL(color_pattern_m = clCreateBuffer(context, CL_MEM_READ_WRITE, 3 * numincol, NULL, &res));

    CLGLBL_HNDL(clEnqueueWriteBuffer(command_queue, color_pattern_m, CL_TRUE, 0, 3 * numincol, incol, 0, NULL, NULL));

    CLGLBL_HNDL(color_output_m = clCreateBuffer(context, CL_MEM_READ_WRITE, 3 * global_item_size[0] * global_item_size[1], NULL, &res));

}


void engine_opencl_end() {
    if (engine_opencl_isvalid) {
        CLGLBL_HNDL(res = clFlush(command_queue));
        CLGLBL_HNDL(res = clFinish(command_queue));
        CLGLBL_HNDL(res = clReleaseKernel(kernel));
        CLGLBL_HNDL(res = clReleaseProgram(program));
        CLGLBL_HNDL(res = clReleaseMemObject(color_pattern_m));
        CLGLBL_HNDL(res = clReleaseMemObject(color_output_m));
        CLGLBL_HNDL(res = clReleaseCommandQueue(command_queue));
        CLGLBL_HNDL(res = clReleaseContext(context));
    }
}


void engine_opencl_fulltest(fractal_img_t * ret) {

    if (!engine_opencl_isvalid) {
        engine_opencl_init(ret->depth, ret->px, ret->py, ret->color.numcol, ret->color.data);
        engine_opencl_isvalid = true;
        gettimeofday(&scl, NULL);
    }

    long long *data = (long long *)ret->data;

    double cX, cY, Z;

    float cXf, cYf, Zf;

    cX = atof(ret->cX);
    cY = atof(ret->cY);
    Z = atof(ret->Z);
    cXf = (float)cX;
    cYf = (float)cY;
    Zf = (float)Z;

    float cdf, cmf;

    cdf = (float)ret->color.disp;
    cmf = (float)ret->color.mult;

    CLGLBL_HNDL(res = clSetKernelArg(kernel, 0, sizeof(cl_mem), (void *)&color_pattern_m));
    CLGLBL_HNDL(res = clSetKernelArg(kernel, 1, sizeof(int), &ret->color.numcol));
    if (using_cl_32) {
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 2, sizeof(float), &cmf));
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 3, sizeof(float), &cdf));
    } else {
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 2, sizeof(double), &ret->color.mult));
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 3, sizeof(double), &ret->color.disp));
    }
    CLGLBL_HNDL(res = clSetKernelArg(kernel, 4, sizeof(int), &ret->color.is_simple));
    CLGLBL_HNDL(res = clSetKernelArg(kernel, 5, sizeof(cl_mem), (void *)&color_output_m));
    CLGLBL_HNDL(res = clSetKernelArg(kernel, 6, sizeof(int), &ret->px));
    CLGLBL_HNDL(res = clSetKernelArg(kernel, 7, sizeof(int), &ret->py));
    CLGLBL_HNDL(res = clSetKernelArg(kernel, 8, sizeof(int), &ret->max_iter));

    if (using_cl_32) {
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 9, sizeof(float), &cXf));
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 10, sizeof(float), &cYf));
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 11, sizeof(float), &Zf));
        float ctimef = ret->ctime;
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 12, sizeof(float), &ctimef));
    } else {
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 9, sizeof(double), &cX));
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 10, sizeof(double), &cY));
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 11, sizeof(double), &Z));
        CLGLBL_HNDL(res = clSetKernelArg(kernel, 12, sizeof(double), &ret->ctime));
    }
    printf("trying local work size [%zu, %zu]...", local_item_size[0], local_item_size[1]);
    CLGLBL_HNDL_S(res = clEnqueueNDRangeKernel(command_queue, kernel, 2, NULL, global_item_size, local_item_size, 0, NULL, NULL),
        if (res == -54) {
            printf("failed\n");

            if (!cargs_get_flag("-CLsize")) {
                local_item_size[0] = 1;
                local_item_size[1] = 1;

                printf("trying local work size [%zu, %zu]...", local_item_size[0], local_item_size[1]);

                CLGLBL_HNDL_S(res = clEnqueueNDRangeKernel(command_queue, kernel, 2, NULL, global_item_size, local_item_size, 0, NULL, NULL),
                    printf("failed\n");
                    printf("size [1, 1] failed. Report this incident!\n");
                    FR_FAIL
                ,
                    printf("worked\n");
                );
            } else {
                printf("ERROR: Local item size (-CLsize) doesn't work! Try removing the option\n");
                FR_FAIL
            }
        } else {
            CLGLBL_HNDL();
        }
    ,
        printf("worked\n");
    );

    CLGLBL_HNDL(res = clEnqueueReadBuffer(command_queue, color_output_m, CL_TRUE, 0, ret->px * ret->py * 3, ret->data, 0, NULL, NULL));

}
