/* engine_opencl/engine_opencl.c -- Engine that uses OpenCL kernel

  Copyright 2016-2017 ChemicalDevelopment

  This file is part of the FractalRender project.

  FractalRender source code, as well as any other resources in this project are
free software; you are free to redistribute it and/or modify them under
the terms of the GNU General Public License; either version 3 of the
license, or any later version.

  These programs are hopefully useful and reliable, but it is understood
that these are provided WITHOUT ANY WARRANTY, or MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GPLv3 or email at
<info@chemicaldevelopment.us> for more info on this.

  Here is a copy of the GPL v3, which this software is licensed under. You
can also find a copy at http://www.gnu.org/licenses/.

*/


#include "fractalrender.h"

/*

imgMeta is width, height, max_iter

meta is cX, cY, and Z

This is a quick abstraction so that the kernel can get this info

*/

// THIS IS AN AUTOGENERATED MACO:
// use `./utils/convert_kernel.py ./kernel.cl` to regenerate


#define ENGINE_OPENCL_KERNEL_SOURCE_DEFAULT "\
__kernel void mand(__global __const int *imgMeta, __global __const double * meta, __global uchar * incol, __global uchar * outcol)\
{\
    int px = get_global_id(0), py = get_global_id(1);\
\
    double x = meta[0] + (2 * px - imgMeta[0]) / (meta[2] * imgMeta[0]), y = meta[1] + (imgMeta[1] - 2 * py) / (meta[2] * imgMeta[0]);\
\
    double sx = x, sy = y, xs = x * x, ys = y * y, tmp;\
    \
    double hue, di, zn;\
\
    double er = 4.0;\
    double er2 = er * er;\
\
    int iter = 1;\
    while (xs + ys <= er2) {\
        tmp = 2 * x * y;\
        x = xs - ys + sx;\
        y = tmp + sy;\
        iter += 1;\
        if (iter >= imgMeta[2]) break;\
        xs = x * x;\
        ys = y * y;\
    }\
\
    zn = xs + ys;\
    di = (double) iter;\
\
    if (zn <= er2) {\
        hue = 0;\
    } else {\
        hue = di + 1 - log(fabs(zn)) / log(er2);\
    }\
    while (hue < 0) {\
        hue += imgMeta[3];\
    }\
    while (hue >= imgMeta[3]) {\
        hue -= imgMeta[3];\
    }\
\
    int sci0 = (int)floor(hue);\
    tmp = hue - sci0;\
\
    int sci1 = sci0 * 3;\
    int sci2;\
\
    if (sci0 >= imgMeta[3] - 1) {\
        sci2 = 0;\
    } else {\
        sci2 = sci1 + 3;\
    }\
\
    int sci3 = 3 * (py * imgMeta[0] + px);\
    outcol[sci3 + 0] = (uchar)(floor(tmp * incol[sci2 + 0] + (1 - tmp) * incol[sci1 + 0]));\
    outcol[sci3 + 1] = (uchar)(floor(tmp * incol[sci2 + 1] + (1 - tmp) * incol[sci1 + 1]));\
    outcol[sci3 + 2] = (uchar)(floor(tmp * incol[sci2 + 2] + (1 - tmp) * incol[sci1 + 2]));\
\
}\
"



bool engine_opencl_isvalid = false;


#define MAX_SOURCE_SIZE (0x100000)

#define CL_MAXPLATFORMS 10
#define CL_MAXDEVICES 10


cl_context context = NULL;
cl_command_queue command_queue = NULL;
cl_program program = NULL;
cl_kernel kernel = NULL;

cl_device_id device_id[CL_MAXDEVICES];
cl_uint res_num_devices;

cl_platform_id platform_id[CL_MAXPLATFORMS];
cl_uint res_num_platforms;

cl_int res;

cl_mem imgMeta_buf = NULL;
cl_mem meta_buf = NULL;
cl_mem incol_buf = NULL;
cl_mem outcol_buf = NULL;


size_t *global_item_size;
size_t *local_item_size;

void engine_opencl_error_handle(char *file, int line, char *src, int code) {
    if (code) {
        printf("OpenCL error code: %d\n", code);
        printf("%s:%d\n", file, line);
        printf("%s\n", src);
        exit(3);
    } else {
        // do nothing, no error
    }
}


#define CLGLBL_HNDL(ST) ST; engine_opencl_error_handle(__FILE__, __LINE__, #ST, res);


void engine_opencl_init(int __depth, int d0, int d1, int numincol, unsigned char *incol) {

    if (engine_opencl_isvalid) {
        return;
    }

    engine_opencl_isvalid = true;
    char *source_str;
    size_t source_size;

    if (cargs_get_flag("-CLkernel")) {
        FILE *fp = fopen(cargs_get("-CLkernel"), "r");
        source_str = (char*)malloc(MAX_SOURCE_SIZE);
        source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);
        fclose(fp);
    } else {
        source_str = ENGINE_OPENCL_KERNEL_SOURCE_DEFAULT;
        source_size = strlen(source_str);
    }
    

    CLGLBL_HNDL(res = clGetPlatformIDs(CL_MAXPLATFORMS, platform_id, &res_num_platforms));

    printf("OpenCL: found %d platforms\n", res_num_platforms);

    // select which device here

    char * cl_dev_type = cargs_get("-CLdevice");
    long clgdif = CL_DEVICE_TYPE_DEFAULT;

    if (strcmp(cl_dev_type, "CPU") == 0) {
        clgdif = CL_DEVICE_TYPE_CPU;
    } else if (strcmp(cl_dev_type, "GPU") == 0) {
        clgdif = CL_DEVICE_TYPE_GPU;
    } else if (strcmp(cl_dev_type, "ALL") == 0) {
        clgdif = CL_DEVICE_TYPE_ALL;
    } else if (strcmp(cl_dev_type, "DEFAULT") == 0) {
        clgdif = CL_DEVICE_TYPE_DEFAULT;
    }

    CLGLBL_HNDL(res = clGetDeviceIDs(platform_id[0], clgdif, CL_MAXDEVICES, device_id, &res_num_devices));

    printf("OpenCL: found %d devices on platform[0]\n", res_num_devices);

    CLGLBL_HNDL(context = clCreateContext(0, 1, device_id, NULL, NULL, &res));
    
    CLGLBL_HNDL(command_queue = clCreateCommandQueue(context, device_id[0], 0, &res));

    CLGLBL_HNDL(program = clCreateProgramWithSource(context, 1, (const char **)&source_str, (const size_t *)&source_size, &res));

    CLGLBL_HNDL(res = clBuildProgram(program, 1, device_id, NULL, NULL, NULL));


    // switch based on kernel
    char *kernel_name = "mand";

    CLGLBL_HNDL(kernel = clCreateKernel(program, kernel_name, &res));

	global_item_size = (size_t *)malloc(sizeof(size_t) * 2);
	local_item_size = (size_t *)malloc(sizeof(size_t) * 2);
	global_item_size[0] = d0;
	global_item_size[1] = d1;
	local_item_size[0] = cargs_get_int_idx("-CLsize", 0);
	local_item_size[1] = cargs_get_int_idx("-CLsize", 1);

    CLGLBL_HNDL(imgMeta_buf = clCreateBuffer(context, CL_MEM_READ_WRITE, 4 * sizeof(int), NULL, &res));

	
    CLGLBL_HNDL(meta_buf = clCreateBuffer(context, CL_MEM_READ_WRITE, 3 * sizeof(double), NULL, &res));

    CLGLBL_HNDL(incol_buf = clCreateBuffer(context, CL_MEM_READ_WRITE, 3 * numincol, NULL, &res));

    CLGLBL_HNDL(outcol_buf = clCreateBuffer(context, CL_MEM_READ_WRITE, global_item_size[0] * global_item_size[1] * 3, NULL, &res));

	CLGLBL_HNDL(clEnqueueWriteBuffer(command_queue, incol_buf, CL_TRUE, 0, 3 * numincol, incol, 0, NULL, NULL));

}


void engine_opencl_end() {
    if (engine_opencl_isvalid) {
        CLGLBL_HNDL(res = clFlush(command_queue));
        CLGLBL_HNDL(res = clFinish(command_queue));
        CLGLBL_HNDL(res = clReleaseKernel(kernel));
        CLGLBL_HNDL(res = clReleaseProgram(program));
        CLGLBL_HNDL(res = clReleaseMemObject(incol_buf));
        CLGLBL_HNDL(res = clReleaseMemObject(outcol_buf));
        CLGLBL_HNDL(res = clReleaseMemObject(meta_buf));
        CLGLBL_HNDL(res = clReleaseMemObject(imgMeta_buf));
        CLGLBL_HNDL(res = clReleaseCommandQueue(command_queue));
        CLGLBL_HNDL(res = clReleaseContext(context));
    }
}


void engine_opencl_fulltest(fractal_img_t * ret) {

    if (!engine_opencl_isvalid) {
        engine_opencl_init(ret->depth, ret->px, ret->py, ret->color.numcol, ret->color.data);
    }


	int *imgMeta = (int *)malloc(4 * sizeof(int));
    double * meta = (double *)malloc(3 * sizeof(double));

    long long *data = (long long *)ret->data;

    imgMeta[0] = ret->px;
    imgMeta[1] = ret->py;
    imgMeta[2] = ret->max_iter;
    imgMeta[3] = ret->color.numcol;

    meta[0] = atof(ret->cX);
    meta[1] = atof(ret->cY);
    meta[2] = atof(ret->Z);

	CLGLBL_HNDL(clEnqueueWriteBuffer(command_queue, imgMeta_buf, CL_TRUE, 0, 4 * sizeof(int), imgMeta, 0, NULL, NULL));

	CLGLBL_HNDL(clEnqueueWriteBuffer(command_queue, meta_buf, CL_TRUE, 0, 3 * sizeof(double), meta, 0, NULL, NULL));

	//clEnqueueWriteBuffer(command_queue, data_buf, CL_TRUE, 0, ret->px * ret->py * sizeof(FR_16BIT), data, 0, NULL, NULL);

    CLGLBL_HNDL(res = clSetKernelArg(kernel, 0, sizeof(cl_mem), (void *)&imgMeta_buf));
    CLGLBL_HNDL(res = clSetKernelArg(kernel, 1, sizeof(cl_mem), (void *)&meta_buf));
	CLGLBL_HNDL(res = clSetKernelArg(kernel, 2, sizeof(cl_mem), (void *)&incol_buf));
	CLGLBL_HNDL(res = clSetKernelArg(kernel, 3, sizeof(cl_mem), (void *)&outcol_buf));

    CLGLBL_HNDL(res = clEnqueueNDRangeKernel(command_queue, kernel, 2, NULL, global_item_size, local_item_size, 0, NULL, NULL));

    CLGLBL_HNDL(res = clEnqueueReadBuffer(command_queue, outcol_buf, CL_TRUE, 0, ret->px * ret->py * 3, ret->data, 0, NULL, NULL));

}



